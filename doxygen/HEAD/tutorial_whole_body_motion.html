<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>sot-doc: Whole body motion</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sot.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sot-doc
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_whole_body_motion.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Whole body motion </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tutorial_snd_introduction"></a>
Introduction</h1>
<p>This tutorial gives a brief high level view of a complete whole body motion with a complex behavior using several components of the SoT.</p>
<p>It is assumed that:</p>
<ol type="1">
<li>the stack of tasks has been installed using the installation instruction provided [there](download);</li>
<li>you understood the [dynamic graph mechanism](a_dynamic_graph).</li>
</ol>
<p>This tutorial details some examples to test the stack of tasks framework on the humanoid robot TALOS.</p>
<h2><a class="anchor" id="tutorial_snd_introduction_melodic"></a>
For Melodic</h2>
<p>To visualize the robot, you need to have ROS and the following packages for ROS Melodic: </p><pre class="fragment">sudo apt-get install ros-melodic-twist-mux ros-melodic-joy-teleop ros-melodic-moveit-ros-move-group ros-melodic-humanoid-nav-msgs ros-melodic-play-motion ros-melodic-ompl ros-melodic-moveit-planners-ompl ros-melodic-moveit-simple-controller-manager
</pre><h2><a class="anchor" id="tutorial_snd_introduction_kinetic"></a>
For Kinetic</h2>
<p>To visualize the robot, you need to have ROS and the following packages for ROS Kinetic: </p><pre class="fragment">sudo apt-get install ros-kinetic-twist-mux ros-kinetic-joy-teleop ros-kinetic-moveit-ros-move-group ros-kinetic-humanoid-nav-msgs ros-kinetic-play-motion ros-kinetic-ompl ros-kinetic-moveit-planners-ompl ros-kinetic-moveit-simple-controller-manager
</pre><p>You also need the following robotpkg binaries: </p><pre class="fragment">sudo apt-get install robotpkg-talos-dev
</pre><p>Make sure that [your environment is properly setup](d_setting_up_environment) and that the environments variables of your terminal contains "/opt/openrobots"</p>
<h1><a class="anchor" id="tutorial_snd_whole_body_motion"></a>
Scripted whole body motion</h1>
<h3>Introduction</h3>
<p>In the following three scripts are used to generate a whole body motion. One starting the Gazebo simulation, the second to start the general SoT framework, the third to generate the control graph and the subsequent whole body motion.</p>
<h3>Start the simulation</h3>
<pre class="fragment">roslaunch talos_gazebo talos_gazebo.launch
</pre><p>WARNING: The first time you are launching this command it might take some time because gazebo is downloading several models from Internet.</p>
<h3>Start the SoT-ROS interface for TALOS in simulation (Gazebo)</h3>
<pre class="fragment">roslaunch roscontrol_sot_talos sot_talos_controller_gazebo.launch
</pre><h3>Start the motion of the robot</h3>
<pre class="fragment">cd /opt/openrobots/share/sot-talos/tests/
python test.py
</pre><h1><a class="anchor" id="tutorial_snd_detailed_explanations"></a>
Explanations</h1>
<h3>Detailed explanation of test.py</h3>
<p>This script is run by a python interpreter outside the real-time control loop of the robot.</p>
<pre class="fragment">#!/usr/bin/python
import sys
import rospy
</pre><p>The first lines are simply import system modules and the ros python interface.</p>
<pre class="fragment">from std_srvs.srv import *
</pre><p>It is used to test if the services provided by the SoT-ROS interface are available.</p>
<pre class="fragment">from dynamic_graph_bridge.srv import *
from dynamic_graph_bridge_msgs.srv import *
</pre><p>Import the helper objects to access services provided by the SoT-ROS interface.</p>
<pre class="fragment">def launchScript(code,title,description = ""):
    raw_input(title+':   '+description)
    rospy.loginfo(title)
    rospy.loginfo(code)
    for line in code:
        if line != '' and line[0] != '#':
            print line
            answer = runCommandClient(str(line))
            rospy.logdebug(answer)
            print answer
        rospy.loginfo("...done with "+title)
</pre><p>This script is loading a python file which will be send to the embedded python interpreter of the SoT. It is waiting the user to hit the enter key after display the python file to be loaded.</p>
<pre class="fragment"># Waiting for services
try:
    rospy.loginfo("Waiting for run_command")
    rospy.wait_for_service('/run_command')
    rospy.loginfo("...ok")

    rospy.loginfo("Waiting for start_dynamic_graph")
    rospy.wait_for_service('/start_dynamic_graph')
    rospy.loginfo("...ok")
</pre><p>This part of the script waits that the services provided by SoT-ROS interface become available: </p><ul>
<li>
<b>run_command which</b> is the service to send python commands. </li>
<li>
<b>start_dynamic_graph</b> is the service to start the control of the robot. </li>
</ul>
<pre class="fragment">runCommandClient = rospy.ServiceProxy('run_command', RunCommand)
runCommandStartDynamicGraph = rospy.ServiceProxy('start_dynamic_graph', Empty)
</pre><p>Two helper objects are created to interact with the services.</p>
<pre class="fragment">initCode = open( "appli.py", "r").read().split("\n")
</pre><p>The file <b>apply.py</b> explained below is loaded in the variable initCode. It basically the control graph that will be applied to the robot.</p>
<pre class="fragment">rospy.loginfo("Stack of Tasks launched")

launchScript(initCode,'initialize SoT')
</pre><p>The last line is sending the script appli.py to the interpreter on the robot.</p>
<pre class="fragment">raw_input("Wait before starting the dynamic graph")
</pre><p>This line prints the string and waits for the user to hit enter</p>
<pre class="fragment">runCommandStartDynamicGraph()
</pre><p>The last line starts to apply the control law to the robot and evaluate the whole SoT control graph.</p>
<pre class="fragment">raw_input("Wait before moving the hand")
</pre><p>This line prints the string and waits for the user to hit enter</p>
<pre class="fragment">runCommandClient("target = (0.5,-0.2,1.0)")
runCommandClient("gotoNd(taskRH,target,'111',(4.9,0.9,0.01,0.9))")
runCommandClient("sot.push(taskRH.task.name)")
</pre><p>The first <b>runCommandClient</b> specifies a target position in (X,Y,Z) coordinates. The second <b>runCommandClient</b> specifies the gains to apply to the task <b>taskRH</b> and the axis to control. Here '111' means that all axis are controlled. The last runCommandClient push the task <b>taskRH</b> in the solver.</p>
<pre class="fragment">except rospy.ServiceException, e:
    rospy.logerr("Service call failed: %s" % e)
</pre><p>The last two lines deals with exception which might raise during the process.</p>
<h3>Detailed explanations of appli.py</h3>
<pre class="fragment">from dynamic_graph.sot.core.meta_tasks_kine import MetaTaskKine6d, MetaTaskKineCom, gotoNd
from dynamic_graph.sot.core.matrix_util import matrixToTuple
from numpy import eye
</pre><p>The first line import object collecting objects to realize generic kinematic tasks.</p>
<p>taskRH = MetaTaskKine6d('rh',robot.dynamic,'rh',robot.OperationalPointsMap['right-wrist']) handMgrip = eye(4); handMgrip[0:3,3] = (0.1,0,0) taskRH.opmodif = matrixToTuple(handMgrip) taskRH.feature.frame('desired')</p>
<p>The first line create a task <b>rh</b> at the operational point 'right-wrist'. The second line creates a homogeneous matrix <b>handMgrip</b> . The rotational part is set to identity and the translation part is set to **(0.1,0.0,0.0)**. The third line set a modification of the operational point. It is such that the controlled frame is 'right-wrist' multiplied at the left by <b>handMgrip</b>.</p>
<pre class="fragment"># --- STATIC COM (if not walking)
taskCom = MetaTaskKineCom(robot.dynamic)
robot.dynamic.com.recompute(0)
taskCom.featureDes.errorIN.value = robot.dynamic.com.value
taskCom.task.controlGain.value = 10
</pre><p>This task controls the CoM of the robot by reading the output of the entity <b>robot.dynamic</b>. The second line initialize the output value of signal <b>robot.dynamic.com</b>. It becomes the desired value in the third line. The control gain is set to 10 in the fourth line.</p>
<pre class="fragment"># --- CONTACTS
#define contactLF and contactRF
contactLF = MetaTaskKine6d('contactLF',robot.dynamic,'LF',robot.OperationalPointsMap['left-ankle'])
contactLF.feature.frame('desired')
contactLF.gain.setConstant(10)
contactLF.keep()
locals()['contactLF'] = contactLF
</pre><p>The first line create a set of object necessary to maintain contact with the left-ankle. The second line specifies the name of the desired feature. The third line specifies the gain of the contact. The fourth line maintains the position as a constraint.</p>
<pre class="fragment">contactRF = MetaTaskKine6d('contactRF',robot.dynamic,'RF',robot.OperationalPointsMap['right-ankle'])
contactRF.feature.frame('desired')
contactRF.gain.setConstant(10)
contactRF.keep()
locals()['contactRF'] = contactRF
</pre><p>The lines specified here are the same than for the previous contact.</p>
<pre class="fragment">from dynamic_graph import plug
from dynamic_graph.sot.core import SOT
</pre><p>The first line import bindings to the lower C++ framework. </p><pre class="fragment">sot = SOT('sot')
sot.setSize(robot.dynamic.getDimension())
plug(sot.control,robot.device.control)
</pre><p>The first line instantiates a solver to generate a kinematic solver. The second line defines the size of free variables. The third line links the solution of the solver to the input of the robot.</p>
<pre class="fragment">from dynamic_graph.ros import RosPublish
ros_publish_state = RosPublish ("ros_publish_state")
ros_publish_state.add ("vector", "state", "/sot_control/state")
</pre><p>The first line import the python module to publish data in the ROS world (aka topics). The second line instantiate the object to make the interface from the Stack-Of-Tasks world to the ROS world. It creates an entity called "ros_publish_state".</p>
<p>The third line adds a topic called **/sot_control/state** from the signal <b>state</b> of the entity <b>ros_publish_state</b> </p><pre class="fragment">plug (robot.device.state, ros_publish_state.state)
robot.device.after.addDownsampledSignal ("ros_publish_state.trigger", 100)
</pre><p>The first line connect the signal <b>robot.device.state</b> to the the signal <b>state</b> of the entity <b>ros_publish_state</b>. The second line calls the signal <b>ros_publish_state.trigger</b> at 100 Hz after evaluating the control law. </p><pre class="fragment">sot.push(contactRF.task.name)
sot.push(contactLF.task.name)
sot.push(taskCom.task.name)
robot.device.control.recompute(0)
</pre><p>The first line push the right foot contact task at the top of the SoT. The second line push the left foot contact task in the SoT. The third line push the CoM task in the SoT. The last line ask for a re-computation of the signal named <b>control</b> which belongs to the entity <b>device</b>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 19 2020 13:37:44 for sot-doc by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
